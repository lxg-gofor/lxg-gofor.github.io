<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>《深入理解Java虚拟机:JVM高级特性与最佳实践》笔记1-jvm内存区域 | LXG’S BLOG</title><meta name="keywords" content="JVM,JVM内存区域"><meta name="author" content="Luo_xguan"><meta name="copyright" content="Luo_xguan"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、走进Java （快速浏览，先略过）1.1 概述 Java不仅仅是一门编程语言，它还是一个由一系列计算机软件和规范组成的技术体系，这个技术体系提供了完整的用于软件开发和跨平台部署的支持环境，并广泛应用于嵌入式系统。  1.2 Java优点  拥有一门结构严谨、面向对象的编程语言。 摆脱了硬件平台的束缚，实现了一次编写，到处运行的理想。 提供了相对安全的内存管理和访问机制，避免了大部分的内存泄露和">
<meta property="og:type" content="article">
<meta property="og:title" content="《深入理解Java虚拟机:JVM高级特性与最佳实践》笔记1-jvm内存区域">
<meta property="og:url" content="http://example.com/2021/11/27/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E3%80%8B%E7%AC%94%E8%AE%B01-jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/index.html">
<meta property="og:site_name" content="LXG’S BLOG">
<meta property="og:description" content="一、走进Java （快速浏览，先略过）1.1 概述 Java不仅仅是一门编程语言，它还是一个由一系列计算机软件和规范组成的技术体系，这个技术体系提供了完整的用于软件开发和跨平台部署的支持环境，并广泛应用于嵌入式系统。  1.2 Java优点  拥有一门结构严谨、面向对象的编程语言。 摆脱了硬件平台的束缚，实现了一次编写，到处运行的理想。 提供了相对安全的内存管理和访问机制，避免了大部分的内存泄露和">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/3.jfif">
<meta property="article:published_time" content="2021-11-27T04:56:47.000Z">
<meta property="article:modified_time" content="2021-11-27T07:28:48.381Z">
<meta property="article:author" content="Luo_xguan">
<meta property="article:tag" content="JVM">
<meta property="article:tag" content="JVM内存区域">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/3.jfif"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/11/27/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E3%80%8B%E7%AC%94%E8%AE%B01-jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '《深入理解Java虚拟机:JVM高级特性与最佳实践》笔记1-jvm内存区域',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-11-27 15:28:48'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/wechathead.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> Java</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Java/Java%E5%9F%BA%E7%A1%80/"><span> Java基础</span></a></li><li><a class="site-page child" href="/categories/Java/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"><span> Java集合框架</span></a></li><li><a class="site-page child" href="/categories/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><span> 并发编程</span></a></li><li><a class="site-page child" href="/categories/Java/JVM/"><span> JVM</span></a></li><li><a class="site-page child" href="/categories/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span> 设计模式</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 计算机基础</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span> 计算机网络</span></a></li><li><a class="site-page child" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span> 操作系统</span></a></li><li><a class="site-page child" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span> 数据结构</span></a></li><li><a class="site-page child" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%AE%97%E6%B3%95/"><span> 算法</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 数据库</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"><span> 数据库基础</span></a></li><li><a class="site-page child" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"><span> MySQL</span></a></li><li><a class="site-page child" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Oracle/"><span> Oracle</span></a></li><li><a class="site-page child" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/"><span> Redis</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 常用框架</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/Spring/"><span> Spring</span></a></li><li><a class="site-page child" href="/categories/%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/SPring%20MVC/"><span> Spring MVC</span></a></li><li><a class="site-page child" href="/categories/%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/Spring%20MyBatis/"><span> Mybatis</span></a></li><li><a class="site-page child" href="/categories/%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/Netty/"><span> Netty</span></a></li><li><a class="site-page child" href="/categories/%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/Spring%20Boot/"><span> Spring Boot</span></a></li><li><a class="site-page child" href="/categories/%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/Spring%20Cloud/"><span> Spring Cloud</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 分布式</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/RPC/"><span> RPC</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 高性能</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/%E9%AB%98%E6%80%A7%E8%83%BD/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"><span> 消息队列</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 高可用</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/%E9%AB%98%E5%8F%AF%E7%94%A8/%E9%9B%86%E7%BE%A4/"><span> 集群</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 读书</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/%E8%AF%BB%E4%B9%A6/%E4%B9%A6%E5%8D%95/"><span> 书单</span></a></li><li><a class="site-page child" href="/categories/%E8%AF%BB%E4%B9%A6/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span> 读书笔记</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/3.jfif')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">LXG’S BLOG</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> Java</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Java/Java%E5%9F%BA%E7%A1%80/"><span> Java基础</span></a></li><li><a class="site-page child" href="/categories/Java/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"><span> Java集合框架</span></a></li><li><a class="site-page child" href="/categories/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><span> 并发编程</span></a></li><li><a class="site-page child" href="/categories/Java/JVM/"><span> JVM</span></a></li><li><a class="site-page child" href="/categories/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span> 设计模式</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 计算机基础</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span> 计算机网络</span></a></li><li><a class="site-page child" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span> 操作系统</span></a></li><li><a class="site-page child" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span> 数据结构</span></a></li><li><a class="site-page child" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%AE%97%E6%B3%95/"><span> 算法</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 数据库</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"><span> 数据库基础</span></a></li><li><a class="site-page child" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"><span> MySQL</span></a></li><li><a class="site-page child" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Oracle/"><span> Oracle</span></a></li><li><a class="site-page child" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/"><span> Redis</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 常用框架</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/Spring/"><span> Spring</span></a></li><li><a class="site-page child" href="/categories/%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/SPring%20MVC/"><span> Spring MVC</span></a></li><li><a class="site-page child" href="/categories/%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/Spring%20MyBatis/"><span> Mybatis</span></a></li><li><a class="site-page child" href="/categories/%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/Netty/"><span> Netty</span></a></li><li><a class="site-page child" href="/categories/%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/Spring%20Boot/"><span> Spring Boot</span></a></li><li><a class="site-page child" href="/categories/%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/Spring%20Cloud/"><span> Spring Cloud</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 分布式</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/RPC/"><span> RPC</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 高性能</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/%E9%AB%98%E6%80%A7%E8%83%BD/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"><span> 消息队列</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 高可用</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/%E9%AB%98%E5%8F%AF%E7%94%A8/%E9%9B%86%E7%BE%A4/"><span> 集群</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 读书</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/%E8%AF%BB%E4%B9%A6/%E4%B9%A6%E5%8D%95/"><span> 书单</span></a></li><li><a class="site-page child" href="/categories/%E8%AF%BB%E4%B9%A6/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span> 读书笔记</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">《深入理解Java虚拟机:JVM高级特性与最佳实践》笔记1-jvm内存区域</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-11-27T04:56:47.000Z" title="发表于 2021-11-27 12:56:47">2021-11-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-11-27T07:28:48.381Z" title="更新于 2021-11-27 15:28:48">2021-11-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/JVM/">JVM</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="《深入理解Java虚拟机:JVM高级特性与最佳实践》笔记1-jvm内存区域"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="一、走进Java-（快速浏览，先略过）"><a href="#一、走进Java-（快速浏览，先略过）" class="headerlink" title="一、走进Java （快速浏览，先略过）"></a>一、走进Java （快速浏览，先略过）</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><blockquote>
<p>Java不仅仅是一门编程语言，它还是一个由一系列计算机软件和规范组成的技术体系，这个技术体系提供了完整的用于软件开发和跨平台部署的支持环境，并广泛应用于嵌入式系统。</p>
</blockquote>
<h3 id="1-2-Java优点"><a href="#1-2-Java优点" class="headerlink" title="1.2 Java优点"></a>1.2 Java优点</h3><blockquote>
<ul>
<li>拥有一门结构严谨、面向对象的编程语言。</li>
<li>摆脱了硬件平台的束缚，实现了一次编写，到处运行的理想。</li>
<li>提供了相对安全的内存管理和访问机制，避免了大部分的内存泄露和指针越界问题。</li>
<li>实现了热点代码检测和运行时编译及优化，使得Java应用能随着运行时间的增长而获得更高的性能。</li>
<li>拥有一套完善的应用程序接口，和无数来自商业机构和开源社区的第三方类库来帮助用户实现各种各样的功能</li>
<li>…</li>
</ul>
</blockquote>
<h3 id="1-3-Java技术体系"><a href="#1-3-Java技术体系" class="headerlink" title="1.3 Java技术体系"></a>1.3 Java技术体系</h3><blockquote>
<ul>
<li>Java程序设计语言</li>
<li>各种硬件平台上的Java虚拟机实现</li>
<li>Class文件格式</li>
<li>Java类库API</li>
<li>来自商业机构和开源社区的第三方Java类库</li>
</ul>
</blockquote>
<p><strong>JDK：</strong></p>
<blockquote>
<p>是Java程序设计语言、Java虚拟机、Java类库的统称，是用于支持Java程序开发的最小环境。</p>
</blockquote>
<p><strong>JRE：</strong></p>
<blockquote>
<p>是Java类库API中JavaSE API子集和Java虚拟机这两部分的统称，JRE是支持Java程序运行的标准环境。</p>
</blockquote>
<p><strong>JVM：</strong></p>
<blockquote>
<p>Java虚拟机，Java能跨平台运行的重要支持。</p>
</blockquote>
<p><strong>Java按照技术关注的重点业务来划分，可分为以下4条主要的产品线</strong></p>
<blockquote>
<p>Java Card</p>
<p>Java ME</p>
<p>Java SE</p>
<p>Java EE</p>
</blockquote>
<h3 id="1-4-Java发展史"><a href="#1-4-Java发展史" class="headerlink" title="1.4 Java发展史"></a>1.4 Java发展史</h3><h3 id="1-5-Java虚拟机家族"><a href="#1-5-Java虚拟机家族" class="headerlink" title="1.5 Java虚拟机家族"></a>1.5 Java虚拟机家族</h3><blockquote>
<ul>
<li>虚拟机始祖：Sun Classic/Exact VM,世界上第一款商用Java虚拟机</li>
<li>武林盟主：HotSpot VM,Sun/OracleJDK 和OpenJDK中默认的Java虚拟机，也是目前使用最广的Java虚拟机。</li>
<li>小家碧玉：Mobile/Embedded VM,Sun/Oracle研发的专门面对移动和嵌入式市场的Java虚拟机</li>
<li>天下第二：BEAJRockit/ IBM J9 VM</li>
<li>软硬联合： BEA Liquid VM / Azul VM</li>
<li>挑战者：Apache Harmony/ Google Androd Dalvik VM</li>
<li>…</li>
</ul>
</blockquote>
<h3 id="1-6-展望Java技术的未来"><a href="#1-6-展望Java技术的未来" class="headerlink" title="1.6 展望Java技术的未来"></a>1.6 展望Java技术的未来</h3><blockquote>
<ul>
<li>无语言倾向：Graal VM</li>
<li>新一代即时编译器</li>
<li>向Native迈进</li>
<li>灵活的胖子：模块化</li>
<li>语言语法持续增强</li>
</ul>
</blockquote>
<h2 id="二、Java运行时内存区域"><a href="#二、Java运行时内存区域" class="headerlink" title="二、Java运行时内存区域"></a>二、Java运行时内存区域</h2><p><strong>概述</strong></p>
<blockquote>
<p>对于Java程序员来说，在JVM自动内存管理机制的帮助下，不需要再为每一个new操作去写配对的delete/free代码，不容易出现内存泄漏和内存溢出的问题，不过，也正是因为Java程序员把控制内存的权力交给了JVM，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那排查错误、修正问题就会成为一项异常艰难的工作。</p>
</blockquote>
<blockquote>
<p><img src="https://img-blog.csdnimg.cn/5189d7b5df704010817f5ef439d22984.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATHVvX3hndWFu,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
</blockquote>
<blockquote>
<p>Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。JDK 1.8 和之前的版本略有不同，下面会介绍到。</p>
</blockquote>
<p><strong>JDK 1.8 之前：</strong></p>
<blockquote>
<p><img src="https://img-blog.csdnimg.cn/052742cdf144497eb6fec08ea555eedd.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATHVvX3hndWFu,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
</blockquote>
<p><strong>JDK 1.8 ：</strong></p>
<blockquote>
<p><img src="https://img-blog.csdnimg.cn/2e3087c91c624ede96827278ef25bc06.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATHVvX3hndWFu,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
</blockquote>
<h3 id="2-1-程序计数器"><a href="#2-1-程序计数器" class="headerlink" title="2.1 程序计数器"></a>2.1 程序计数器</h3><p><strong>概述：</strong></p>
<blockquote>
<p>是一块较小的内存空间，可以看作当前线程所执行的字节码的一个行号指示器，在Java虚拟机的概念模型里面，字节码解释器工作的时候，就是通过改变程序计数器的值来选取下一条需要执行的字节码指令，即字程序计数器里面存的值是当前线程所需要执行的下一条指令的地址。</p>
</blockquote>
<blockquote>
<p>程序计数器是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖程序计数器来完成。</p>
</blockquote>
<blockquote>
<p>在JVM中多多线程的执行机制是通过线程轮流切换、分配处理器执行时间等方式即时间片轮转的方式来实现的，在任何一个确定的时间，一个处理器都只执行一个线程中的指令，因此，为了线程切换后每个被中断的线程能够恢复到被中断前的执行位置，每个线程都需要一个独立的程序计数器来记录线程信息，各条线程之间的计数器互不影响、独立存储。</p>
</blockquote>
<p><strong>作用：</strong></p>
<blockquote>
<p>1.是记住下一条jvm指令的执行地址，是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖程序计数器来完成。</p>
<p>2.在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</p>
</blockquote>
<p><strong>特点：</strong></p>
<blockquote>
<p>1.线程私有：每个线程都有对应的程序计数器，互不影响。</p>
<p>2.是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域，即不会有内存溢出的情况。它的生命周期随着线程的创建而创建，随着线程的死亡而死亡。</p>
</blockquote>
<h3 id="2-2-Java虚拟机栈"><a href="#2-2-Java虚拟机栈" class="headerlink" title="2.2 Java虚拟机栈"></a>2.2 Java虚拟机栈</h3><p><strong>概述</strong></p>
<blockquote>
<ol>
<li>Java虚拟机栈，线程私有，生命周期与线程相同。</li>
<li>描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个<strong>栈帧</strong> （Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。</li>
<li>每一个方法被调用直至执行完毕，就对应着一个栈帧在虚拟机栈中的出栈入栈的过程。<br><img src="https://img-blog.csdnimg.cn/5653f68e71c5409c87e97bb7804da664.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATHVvX3hndWFu,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li>
</ol>
</blockquote>
<blockquote>
<ol start="4">
<li><strong>局部变量表主要存放了编译期可知的各种数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。<br><img src="https://img-blog.csdnimg.cn/ac098e230bf34a30ae1e5b388ad6fe0c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATHVvX3hndWFu,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li>
</ol>
</blockquote>
<blockquote>
<ol start="5">
<li><p><strong>Java虚拟机栈会出现两种错误：</strong> <strong><code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code>。</strong></p>
<p><strong>StackOverFlowError</strong>：如果线程请求的栈深度大于虚拟机所允许的栈深度，就抛出此异常。</p>
<p><strong>OutOfMemoryError：</strong> 如果Java虚拟机栈可以动态扩展，当扩展的时候无法申请到足够的内存就会报该异常。</p>
</li>
</ol>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/9b5ca407d4bc4bbc84b6c6cd40067abc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATHVvX3hndWFu,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><strong>特点</strong></p>
<blockquote>
<p>1.线程私有，生命周期与线程相同，随着线程的创建而创建，随着线程的死亡而死亡。</p>
<p>2.存在这TtackOverflowError 和OutOfMemoryError两种异常。</p>
<p>3.局部变量表随着栈帧的创建而创建，它的大小在编译时确定，创建时只需分配事先规定的大小即可。在方法运行过程中，局部变量表的大小不会发生改变。</p>
<p>4.一个栈有多个栈帧。活动栈帧只有一个，对应着当前正在执行的方法。</p>
</blockquote>
<p><strong>IDEA演示栈帧</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> jvm.t1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示栈帧</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1_1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        method1();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        method2(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method2</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = a+b;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用Debug运行上述代码，可以在IDEA中模拟栈帧，如下图</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/905e2e4d84754c4da8d3f4051e6398ce.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATHVvX3hndWFu,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><strong>扩展</strong></p>
<ol>
<li><p><strong>那么方法/函数如何调用？</strong></p>
<blockquote>
<p>Java 栈可以类比数据结构中栈，Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。</p>
<p>Java 方法有两种返回方式：</p>
<p>1.return 语句。</p>
<p>2.抛出异常。</p>
<p>不管哪种返回方式都会导致栈帧被弹出。</p>
</blockquote>
</li>
<li><p><strong>垃圾回收是否涉及栈内存？</strong></p>
<blockquote>
<p>不涉及，堆是线程运行需要的空间，随线程的产生而产生，随线程消亡而消亡，是线程私有的内存，不需要垃圾回收机制来回收，垃圾回收机制只回收堆中的内存。</p>
</blockquote>
</li>
<li><p><strong>栈内存越大越好吗？</strong></p>
<blockquote>
<p>并不是越大越好,栈是线程私有的，物理内存大小固定，如果给栈划分内存过大，导致线程数量变少。</p>
<p><strong>给栈内存指定大小：</strong> -Xss size<br>-Xss 1m<br>-Xss 1024k<br>-Xss 1048576</p>
</blockquote>
</li>
<li><p><strong>方法内部的局部变量是否线程安全？</strong></p>
<blockquote>
<p>线程安全，因为栈是线程私有的，当一个线程执行一个方法时，会创建一个独立的栈帧，局部变量存储在栈帧的局部变量表中，每个线程之间的栈帧互不影响。</p>
<ul>
<li><p>如果方法内局部变量的作用范围没有逃离方法的作用范围，那么就是线程安全的</p>
</li>
<li><p>如果是局部变量引用了对象，并逃离了方法的作用范围，就需要考虑线程安全。</p>
</li>
</ul>
</blockquote>
</li>
</ol>
<p><strong>栈内存溢出演示</strong></p>
<blockquote>
<p><strong>1.栈帧过多导致栈内存溢出，比如没有适当结束条件的递归调用就是因为栈帧过多产生栈内存溢出</strong></p>
</blockquote>
<p>​                </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> jvm.t1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示栈内存溢出 java.lang.StackOverflowError</span></span><br><span class="line"><span class="comment"> * -Xss 256k</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1_2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            method1();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">        method1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>分析：</p>
<p>如上代码，由于递归方法没有退出，导致内存溢出。</p>
</blockquote>
<blockquote>
<p><strong>2.栈帧过大导致栈内存溢出。</strong></p>
</blockquote>
<h3 id="2-3-本地方法栈"><a href="#2-3-本地方法栈" class="headerlink" title="2.3 本地方法栈"></a>2.3 本地方法栈</h3><p><strong>概述</strong></p>
<blockquote>
<p>和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p>
<p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p>
<p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 <code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code> 两种错误。</p>
</blockquote>
<h3 id="2-4-Java堆"><a href="#2-4-Java堆" class="headerlink" title="2.4 Java堆"></a>2.4 Java堆</h3><p><strong>概述</strong></p>
<blockquote>
<p><strong>Java 堆（Java Heap）</strong> 是虚拟机所管理的最大的一块内存，<strong>被所有的线程共享，在虚拟机启动时创建。此内存的唯一目的就是存放对象实例，Java世界几乎所有的对象实例都是在这里分配内存。</strong></p>
</blockquote>
<blockquote>
<p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC 堆（Garbage Collected Heap）</strong>。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代；再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong> </p>
</blockquote>
<blockquote>
<p><strong>在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：</strong></p>
</blockquote>
<blockquote>
<ol>
<li>新生代内存(Young Generation)</li>
<li>老生代(Old Generation)</li>
<li>永生代(Permanent Generation)<br><img src="https://img-blog.csdnimg.cn/927f8801f3dd4977854449ce582e566d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATHVvX3hndWFu,size_18,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li>
</ol>
</blockquote>
<blockquote>
<p><strong>JDK 8 版本之后方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/ca4940faa9364927af526cbd047b2463.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATHVvX3hndWFu,size_18,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>上图所示的 Eden 区、两个 Survivor 区都属于新生代（为了区分，这两个 Survivor 区域按照顺序被命名为 from 和 to），中间一层属于老年代。</strong></p>
<p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p>
</blockquote>
<blockquote>
<p><strong>从分配内存的角度看</strong> ,所有线程共享的Java堆可以划分出多个<strong>线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）</strong>，以提升对象分配时的效率。</p>
</blockquote>
<blockquote>
<p>根据《Java虚拟机规范》的规定，Java堆可以处于物理上不连续的内存空间，但是在逻辑上应该被视为连续的</p>
</blockquote>
<blockquote>
<p>Java 堆既可以被实现为大小固定的，也是可以扩展的，当下主流的Java虚拟机中的堆都是可以扩展的，扩展命令：</p>
<p>-Xmx和-Xms来设定</p>
</blockquote>
<p><strong>堆这里最容易出现的就是 OutOfMemoryError 错误，并且出现这种错误之后的表现形式还会有几种，比如：</strong></p>
<blockquote>
<ol>
<li><p><strong><code>java.lang.OutOfMemoryError: GC Overhead Limit Exceeded</code></strong> ： 当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。</p>
</li>
<li><p><strong><code>java.lang.OutOfMemoryError: Java heap space</code></strong> :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误。(和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过<code>-Xmx</code>参数配置，若没有特别配置，将会使用默认值</p>
</li>
</ol>
</blockquote>
<h3 id="2-5-方法区"><a href="#2-5-方法区" class="headerlink" title="2.5 方法区"></a>2.5 方法区</h3><p><strong>概述</strong></p>
<blockquote>
<p><strong>方法区（Method Area）</strong> 与Java堆一样，是线程共享的内存区域，用于存储存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码缓存等数据。<strong>Java虚拟机规范把方法区描述为堆的一个逻辑部分，</strong> 但是它却有一个别名叫做“非堆”，目的是与Java堆区分开来。</p>
</blockquote>
<p><strong>方法区和永久代的关系</strong></p>
<blockquote>
<p>Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 <strong>方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。</strong> 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。</p>
</blockquote>
<p><strong>常用参数</strong></p>
<blockquote>
<p>JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:PermSize=N <span class="comment">//方法区 (永久代) 初始大小</span></span><br><span class="line">-XX:MaxPermSize=N <span class="comment">//方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。</p>
<p>JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。</p>
<p>下面是一些常用参数：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=N <span class="comment">//设置 Metaspace 的初始（和最小大小）</span></span><br><span class="line">-XX:MaxMetaspaceSize=N <span class="comment">//设置 Metaspace 的最大大小</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。</p>
</blockquote>
<p><strong>为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢？</strong></p>
<blockquote>
<ol>
<li><p>使用永久代来实现方法区导致了Java应用容易遇到内存溢出的问题（永久代有-XX:MaxPermSize 的上限，即使不设置也有默认大小，而J9 和JRockit只要没有触碰到线程可用内存的上限，例如32位系统中的4GB限制，就不会出现问题），而且有极少数的方法例如String：：intern()会因为永久代的原因而导致不同虚拟机下有不同的表现。</p>
</li>
<li><p>在JDK6的时候，HotSpot开发团队就有放弃永久代，逐步改为采用本地内存（Native Memory）来实现方法区的计划了，到了JDK7的HotSpot，已经把原本放在永久代的字符串常量、静态变量等移除，而到了JDK 8，终于完全废弃了永久代的概念，改用了JRockit\J9一样的在本地内存中实现的元空间（Meta-space）来替代，把JDK 7中永久代还剩余的内容（主要是类型信息）全部移动到元空间中。</p>
</li>
<li><p>整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当元空间溢出时会得到如下错误： `java.lang.OutOfMemoryError: MetaSpace`</span><br></pre></td></tr></table></figure>

<p>可以使用 <code>-XX：MaxMetaspaceSize</code> 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。<code>-XX：MetaspaceSize</code> 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。 —– 著作权归Guide哥所有。</p>
</li>
<li><p>元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 <code>MaxPermSize</code> 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。</p>
</li>
<li><p>在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。</p>
</li>
</ol>
</blockquote>
<p><strong>其他</strong></p>
<blockquote>
<ol>
<li>《Java虚拟机规范》对方法区的约束是非常宽松的，除了和Java堆一样不需要连续的物理内存和可以选额固定的大小或可扩展外，甚至还可以选择不是先垃圾收集。</li>
<li>进入方法区的数据并非永久存在的。这个区域的内存回收主要针对的是对常量池的回收和对类型的卸载，条件相当苛刻，但是这部分区域的回收有时又是非常必要的。</li>
<li>如果方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常。</li>
</ol>
</blockquote>
<h3 id="2-6-运行时常量池"><a href="#2-6-运行时常量池" class="headerlink" title="2.6 运行时常量池"></a>2.6 运行时常量池</h3><blockquote>
<p><strong>运行时常量池（Runtime Constant Pool）</strong> 是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池表（Contant Pool Table），用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量表池中。</p>
</blockquote>
<blockquote>
<p>运行时常量池具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也能将新的常量放入常量池当中，被利用的比较多的就是String类的intern()方法。</p>
</blockquote>
<blockquote>
<p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 错误。</p>
</blockquote>
<blockquote>
<ol>
<li><strong>JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代</strong></li>
<li><strong>JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是 hotspot 中的永久代</strong> 。</li>
<li><strong>JDK1.8 hotspot 移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)</strong></li>
</ol>
</blockquote>
<h3 id="2-7直接内存"><a href="#2-7直接内存" class="headerlink" title="2.7直接内存"></a>2.7直接内存</h3><blockquote>
<p><strong>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。</strong></p>
</blockquote>
<blockquote>
<p>JDK1.4 中新加入的 <strong>NIO(New Input/Output) 类</strong>，引入了一种基于**通道（Channel）**与**缓存区（Buffer）**的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为**避免了在 Java 堆和 Native 堆之间来回复制数据**。</p>
</blockquote>
<blockquote>
<p>本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。动态扩展时可能会出现OutOFMemoryError异常。</p>
</blockquote>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="https://weread.qq.com/web/reader/cf1320d071a1a78ecf19254kc81322c012c81e728d9d180">周志明老师的《深入理解Java虚拟机：JVM高级特性与最佳实践(第3版)》</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Luo_xguan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/11/27/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E3%80%8B%E7%AC%94%E8%AE%B01-jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/">http://example.com/2021/11/27/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E3%80%8B%E7%AC%94%E8%AE%B01-jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">LXG’S BLOG</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/">JVM</a><a class="post-meta__tags" href="/tags/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/">JVM内存区域</a></div><div class="post_share"><div class="social-share" data-image="/images/3.jfif" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/11/27/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E3%80%8B%E7%AC%94%E8%AE%B02-HotSpot%E5%AF%B9%E8%B1%A1%E6%8E%A2%E7%A7%98/"><img class="prev-cover" src="/images/11.jfif" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">《深入理解Java虚拟机:JVM高级特性与最佳实践》笔记2-HotSpot对象探秘</div></div></a></div><div class="next-post pull-right"><a href="/2021/11/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/"><img class="next-cover" src="/images/2.jfif" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">设计模式总结</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/11/27/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E3%80%8B%E7%AC%94%E8%AE%B02-HotSpot%E5%AF%B9%E8%B1%A1%E6%8E%A2%E7%A7%98/" title="《深入理解Java虚拟机:JVM高级特性与最佳实践》笔记2-HotSpot对象探秘"><img class="cover" src="/images/11.jfif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-27</div><div class="title">《深入理解Java虚拟机:JVM高级特性与最佳实践》笔记2-HotSpot对象探秘</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/wechathead.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Luo_xguan</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/lxg-gofor" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:luoxiaoguan@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%B5%B0%E8%BF%9BJava-%EF%BC%88%E5%BF%AB%E9%80%9F%E6%B5%8F%E8%A7%88%EF%BC%8C%E5%85%88%E7%95%A5%E8%BF%87%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">一、走进Java （快速浏览，先略过）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Java%E4%BC%98%E7%82%B9"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 Java优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-Java%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 Java技术体系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-Java%E5%8F%91%E5%B1%95%E5%8F%B2"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 Java发展史</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%B6%E6%97%8F"><span class="toc-number">1.5.</span> <span class="toc-text">1.5 Java虚拟机家族</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-%E5%B1%95%E6%9C%9BJava%E6%8A%80%E6%9C%AF%E7%9A%84%E6%9C%AA%E6%9D%A5"><span class="toc-number">1.6.</span> <span class="toc-text">1.6 展望Java技术的未来</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Java%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F"><span class="toc-number">2.</span> <span class="toc-text">二、Java运行时内存区域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 程序计数器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 Java虚拟机栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 本地方法栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-Java%E5%A0%86"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 Java堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">2.5.</span> <span class="toc-text">2.5 方法区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">2.6.</span> <span class="toc-text">2.6 运行时常量池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="toc-number">2.7.</span> <span class="toc-text">2.7直接内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">2.8.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/12/09/%E8%AF%BB%E3%80%8A%E4%B8%BB%E8%A7%92%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%8C%E6%91%98%E8%AE%B0%E7%A7%A6%E8%85%94%E7%9A%87%E5%90%8E%E5%BF%86%E7%A7%A6%E5%A8%A5%E7%9A%84%E5%8D%8A%E7%94%9F%E6%B5%AE%E6%B2%89/" title="读《主角》笔记，摘记秦腔皇后忆秦娥的半生浮沉">读《主角》笔记，摘记秦腔皇后忆秦娥的半生浮沉</a><time datetime="2021-12-09T07:11:47.000Z" title="发表于 2021-12-09 15:11:47">2021-12-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/12/09/%E4%BA%BA%E4%BB%AC%E5%9C%A8%E4%B8%80%E6%9C%AC%E5%8F%AB%E5%81%9A%E3%80%8A%E6%B4%BB%E7%9D%80%E3%80%8B%E7%9A%84%E4%B9%A6%E4%B8%AD%E7%BA%B7%E7%BA%B7%E6%AD%BB%E5%8E%BB/" title="人们在一本叫做《活着》的书中纷纷死去">人们在一本叫做《活着》的书中纷纷死去</a><time datetime="2021-12-09T07:05:26.000Z" title="发表于 2021-12-09 15:05:26">2021-12-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/12/09/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/" title="Java集合框架面试题总结">Java集合框架面试题总结</a><time datetime="2021-12-09T06:34:51.000Z" title="发表于 2021-12-09 14:34:51">2021-12-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/12/09/java%E5%9F%BA%E7%A1%80-Java%E5%85%A5%E9%97%A8/" title="java基础:Java入门">java基础:Java入门</a><time datetime="2021-12-09T06:25:46.000Z" title="发表于 2021-12-09 14:25:46">2021-12-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/11/27/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E3%80%8B%E7%AC%94%E8%AE%B02-HotSpot%E5%AF%B9%E8%B1%A1%E6%8E%A2%E7%A7%98/" title="《深入理解Java虚拟机:JVM高级特性与最佳实践》笔记2-HotSpot对象探秘">《深入理解Java虚拟机:JVM高级特性与最佳实践》笔记2-HotSpot对象探秘</a><time datetime="2021-11-27T12:16:48.000Z" title="发表于 2021-11-27 20:16:48">2021-11-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Luo_xguan</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>